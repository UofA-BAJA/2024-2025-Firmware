/*
 *  Warning! DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING!
 *
 *
 *  Class: Car
 *
 *         Author:  Matthew Larson
 *
 *        Purpose:  Defines the components of the car: procedure scheduler, can dispatcher, data storage, car logger,
 *        and car container; Runs 
 *
 *  Inherits From:  None
 *
 *     Interfaces:  None
 *
 *+-----------------------------------------------------------------------
 *
 *      Constants:  None
 *
 *+-----------------------------------------------------------------------
 *
 *   Constructors:  Car()
 *
 *  Class Methods:  None
 *
 *  Inst. Methods:  void execute() -- Runs the main car loop; calls the various subsystems
 *                  void init() -- Placeholder for tasks that need to happen before the subsystems start 
 *                  void end() -- Stops the procedureScheduler 
 *
*/


// I'm not sure why I need this preprocessor, but this works...
// https://stackoverflow.com/questions/68742519/why-cant-i-use-the-nanosleep-function-even-when-time-h-is-includedhttps://stackoverflow.com/questions/68742519/why-cant-i-use-the-nanosleep-function-even-when-time-h-is-included
#define _POSIX_C_SOURCE 199309L

#include "Car.h"

namespace BajaWildcatRacing
{

    bool g_running;


    /*
    *  Method: car() 
    *
    *  Purpose: Constructs the car object; initializes car logger, procedure scheduler, CAN dispatcher,
    *  coms, and carContainer; starts main car loop.
    *
    *  Pre-condition: The car loop hasn't already been started.
    *
    *  Post-condition: The car loop is started
    *
    *  @param none
    *
    *  @returns none 
    *
    */
    Car::Car() 
    : dataStorage(dataStoragePath)
    , procedureScheduler()
    , canDispatcher(canInterface)
    , coms(procedureScheduler)
    , carContainer(procedureScheduler, canDispatcher, dataStorage, coms)

    {

        std::signal(SIGSEGV, signal_handler); 
        std::signal(SIGINT, signal_handler);
        std::signal(SIGTERM, signal_handler);

    

        // Init behavior that needs to be called before the subsystems start running.
        init();

        CarLogger::Initialize(logPath);

        dataStorage.startNewSession("Test session name O.o");

        procedureScheduler.receiveComCommand(Command::DEFAULT_CAR_START);

        std::cout << "Car Sucessfully Initialized" << std::endl;

        execute();
    }

    /*
    *  Method: ~car() 
    *
    *  Purpose: Calls end(); Destructs the car object
    *
    *  Pre-condition: None
    *
    *  Post-condition: The car object is destroyed
    *
    *  @param none
    *
    *  @returns none 
    *
    */
    Car::~Car(){
        // Later on we'll probably call this function as a command from the pit. Actually, 
        // the car should theoretically never be destroyed unless the program quits, which
        // should never happen while the car is running. 
        // end();
    }

    /*
    *  Method: execute
    *
    *  Purpose: Main loop for running the car; executes proceedure scheduler,
    *  CAN dispatcher, coms, data logging; maintains a stable loop frequency
    *
    *  Pre-condition: 
    *
    *  Post-condition: The method enters an infinite loop to execute everything at BASE_CAR_FREQUENCY.
    *
    *  @param none
    *
    *  @returns none 
    *
    */
    void Car::execute(){

        g_running = true;

        using namespace std::chrono;

        // ! Does not work with frequency 1 for whatever reason...
        int frequency = BASE_CAR_FREQUENCY;   // CAN can go up to 1 Mhz or 1000000 hz

        float cycleTime = 1.0 / frequency;  // Length of time to sleep
        int cycleTimens = (int)(cycleTime * 1000000000L);


        // I'm not exactly sure if this is exactly what we want, but it "should" be good enough for now
        
        steady_clock::time_point absoluteStart;
        absoluteStart = steady_clock::now();


        steady_clock::time_point startTime;
        steady_clock::time_point endTime;

        while(g_running){
            startTime = steady_clock::now();
            double time = duration_cast<nanoseconds>(startTime - absoluteStart).count();

            // std::cout << time / 1000000000L << std::setprecision(9) << std::endl;

            procedureScheduler.execute();
            canDispatcher.execute();
            CarTime::setCurrentTimeSeconds(time / 1000000000L);
            dataStorage.execute(CarTime::getCurrentTimeSeconds());
            coms.execute(CarTime::getCurrentTimeSeconds());

            endTime = steady_clock::now();

            double timeTaken = duration_cast<nanoseconds>(endTime - startTime).count();

            // std::cout << timeTaken / 1000000.0 << std::setprecision(9) << std::endl;

            if(timeTaken < cycleTimens){
                // req defines a time value required by nanosleep 
                struct timespec req = {0};
                req.tv_sec = 0;
                req.tv_nsec = cycleTimens - timeTaken;
                nanosleep(&req, (struct timespec *)NULL);
            }
            else{
                std::cout << "Please stop you're like genuinely killing the raspberry pi with how much work it's doing" << std::endl;
                CarLogger::LogError("Car Computer cycle takes longer to compute than frequency");
            }
        }


        end();

    }

    /*
    *  Method: init
    *
    *  Purpose: Placeholder for tasks that need to happen before the subsystems start 
    *
    *  Pre-condition: None
    *
    *  Post-condition:
    *
    *  @param none
    *
    *  @returns none 
    *
    */
    void Car::init(){
        // std::cout << "Car Sucessfully Initialized\n";
    }

    /*
    *  Method: end
    *
    *  Purpose: Stops the procedureScheduler 
    *
    *  Pre-condition: None
    *
    *  Post-condition: 
    *
    *  @param none
    *
    *  @returns none 
    *
    */
    void Car::end(){
	// Ends currently running procedures
        procedureScheduler.end();
	    dataStorage.endCurrentSession();
        dataStorage.end();
	    canDispatcher.end();
        // coms

	// When the objects go out of scope, their destructors will be called.
	// They only need destructors if they have dynamically managed memory. 	

        std::cout << "Car successfully ended" << std::endl;
    }

    void Car::signal_handler(int signal_num) 
    { 

        if (signal_num == SIGINT || signal_num == SIGTERM) {
            g_running = false;
        }
        else{
            std::cout << "Interrupt signal is (" << signal_num << ").\n"; 
            exit(signal_num); 
        }
     
    } 

}

