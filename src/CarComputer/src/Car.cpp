/* 
 * Represents the car as a whole, controlling the procedure scheduler, car container, and coms.
 * PLEASE DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING!
 * 
 * 
 * Author: Matthew Larson
 */

#include <iostream>
#include <time.h>
#include <cstdlib>
#include "Car.h"
#include "CarContainer.h"
#include "ProcedureScheduler.h"


// Mostly stuff for the CAN socket programming
#include <cstring>      // For strerror()
#include <cstdlib>      // For exit()
#include <unistd.h>     // For close()
#include <sys/socket.h>
#include <linux/can.h>
#include <linux/can/raw.h>
#include <net/if.h>
#include <sys/ioctl.h>


// I'm not sure why I need this preprocessor, but this works...
// https://stackoverflow.com/questions/68742519/why-cant-i-use-the-nanosleep-function-even-when-time-h-is-includedhttps://stackoverflow.com/questions/68742519/why-cant-i-use-the-nanosleep-function-even-when-time-h-is-included
#define _POSIX_C_SOURCE 199309L


ProcedureScheduler procedureScheduler;

Car::Car() {
    // Init behavior that needs to be called before the subsystems start running.
    init();

    CarContainer carContainer = CarContainer(procedureScheduler, can_socket_fd);

    procedureScheduler.init();

    procedureScheduler.receiveComCommand(Command::START_LOG);


    execute();
}


Car::~Car(){
    // Later on we'll probably call this function as a command from the pit. Actually, 
    // the car should theoretically never be destroyed unless the program quits, which
    // should never happen while the car is running. 
    end();
}

void Car::execute(){
    // ! WARNNING: not tested on raspberry pi. 
    // ! Does not work with frequency 1 for whatever reason...
    int frequency = 400;   // CAN can go up to 1 Mhz or 1000000 hz

    float cycleTime = 1.0 / frequency;  // Length of time to sleep
    int cycleTimens = (int)(cycleTime * 1000000000L);


    // I'm not exactly sure if this is exactly what we want, but it "should" be good enough for now

    while(1){
        // req defines a time value required by nanosleep 
        struct timespec req = {0};
        req.tv_sec = 0;
        req.tv_nsec = cycleTimens;
        nanosleep(&req, (struct timespec *)NULL);

        procedureScheduler.execute();
    }

    // printing for other subsystems only works if you print something to the terminal...?
    std::cout << "";
}

void Car::init(){

    const char* can_interface = "can0";

    can_socket_fd = open_can_socket(can_interface);

    std::cout << "Car Sucessfully Initialized\n";
}

void Car::end(){
    procedureScheduler.end();
    std::cout << "Car sucessfully destroyed\n";
}


int Car::open_can_socket(const char* interface){
    int socket_fd = socket(PF_CAN, SOCK_RAW, CAN_RAW);                  // socket returns a file descriptor for a socket
    if(socket_fd < 0){
        std::cerr << "Error while opening socket: " << strerror(errno) << std::endl;
        exit(EXIT_FAILURE);
    }

    struct ifreq ifr;                       // ifreq is used in networking to interact with network interfaces. In this case, the can0 interface.

    // Copy the interface str (can0) into ifr.name
    strcpy(ifr.ifr_name, interface);
    // ioctl (input and output control) is used to talk to device drivers. In this case, we are getting the network index of the interface and binding it to the socket. 
    if(ioctl(socket_fd, SIOGIFINDEX, &ifr) < 0){
        std::cerr << "Error getting interface index: " << strerror(errno) << std::endl;
        close(socket_fd);
        exit(EXIT_FAILURE);
    }

    struct sockaddr_can addr;
    memset(&addr, 0, sizeof(addr));         // Zero the struct to avoid junk values.
    addr.can_family = AF_CAN;
    addr.can_ifindex = ifr.ifr_ifindex;

    if(bind(socket_fd, (struct sockaddr *)&addr, sizeof(addr)) < 0){
        std::cerr << "Error in socket bind: " << strerror(errno) << std::endl;
        close(socket_fd);
        exit(EXIT_FAILURE);
    }

    return socket_fd;
}