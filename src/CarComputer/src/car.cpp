/* 
 * Represents the car as a whole, controlling the various subsystems
 * PLEASE DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING!
 * 
 * 
 * Author: Matthew Larson
 */

#include <iostream>
#include <time.h>
#include <cstdlib>
#include "car.h"


// I'm not sure why I need this preprocessor, but this works...
// https://stackoverflow.com/questions/68742519/why-cant-i-use-the-nanosleep-function-even-when-time-h-is-includedhttps://stackoverflow.com/questions/68742519/why-cant-i-use-the-nanosleep-function-even-when-time-h-is-included
#define _POSIX_C_SOURCE 199309L


Car::Car(){
    // All of the subsystems constructor's are alreading being called. So only 
    // Write code relevant to the car here.
    init();
    execute();
}


Car::~Car(){
    // Later on we'll probably call this function as a command from the pit. Actually, 
    // the car should theoretically never be destroyed unless the program quits, which
    // should never happen while the car is running. 
    end();
}

void Car::execute(){
    // ! WARNNING: not tested on raspberry pi. 
    // ! Does not work with frequency 1 for whatever reason...
    int frequency = 200;   // CAN can go up to 1 Mhz or 1000000 hz

    float cycleTime = 1.0 / frequency;  // Length of time to sleep
    int cycleTimens = (int)(cycleTime * 1000000000L);

    int i = 0;

    // I'm not exactly sure if this is exactly what we want, but it "should" be good enough for now

    while(1){
        // req defines a time value required by nanosleep 
        struct timespec req = {0};
        req.tv_sec = 0;
        req.tv_nsec = cycleTimens;
        nanosleep(&req, (struct timespec *)NULL);

        for(int i = 0; i < numSubsystems; i++){
            subsystems[i].execute();
        }

    }

    // printing for other subsystems only works if you print something to the terminal...?
    std::cout << "";
}

void Car::init(){

    for(int i = 0; i < numSubsystems; i++){
        subsystems[i].init();
    }

    std::cout << "Car Sucessfully Initialized\n";
}

void Car::end(){
    for(int i = 0; i < numSubsystems; i++){
        subsystems[i].end();
    }
    std::cout << "Car sucessfully destroyed\n";
}

/* 
 * Adds a subsystem to the car, binding it to the clock, 
 * initialization, and termination functions.
 * 
 * Parameter: 
 *      subsystem -- the subsystem to bind to the car
 * 
 * Returns: EXIT_SUCCESS for successful binding and
 * EXIT_FAILURE for insucessful binding. 
 */
int Car::BindSubsystem(Subsystem subsystem){

    if(numSubsystems >= MAX_DEVICES){
        std::cout << "Number of subsystems is at its max. ";
        std::cout << subsystem.toString() << " will not be included in the car.\n";
        return EXIT_FAILURE;
    }

    subsystems[numSubsystems] = subsystem;
    numSubsystems++;

    return EXIT_SUCCESS;
}